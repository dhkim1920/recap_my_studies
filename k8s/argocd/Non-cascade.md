# **Non Cascade 삭제란?**

## 삭제의 종류

### 기본 삭제
- 별도의 옵션 없이 삭제하면 Argo CD 애플리케이션 객체와 그 앱이 관리하던 쿠버네티스 리소스가 **모두 삭제**된다.

### Non-Cascade 삭제**
- **개념:** Argo CD 애플리케이션 연결만 끊고, 실제 쿠버네티스 클러스터의 리소스는 **삭제하지 않고 유지**하는 방식
- **사용 방법:** 삭제 시 **'Non-cascade'** 옵션을 체크
- **결과:** Argo CD에서는 앱이 사라지지만, `kubectl`로 조회 시 리소스는 정상적으로 실행 중인 것을 확인 할 수 잇다.

---

## 실제 삭제로 인한 이슈 사례들

### 사례 1. argo cd namespace 삭제에 따른 관리 어플리케이션 전체 삭제

- **상황:** Argo CD를 네임스페이스를 정리하기 위해 `kubectl delete ns argocd` 명령어를 실행
- **원인:** Argo CD가 관리하던 애플리케이션들에는 `Finalizer`가 설정된 상태
- **결과:** Argo CD 컨트롤러는 자신이 삭제되기 직전, "관리하던 앱들도 다 삭제"라고 판단하고 **운영 중인 모든 서비스 네임스페이스를 전부 삭제**
- Argo CD 자체를 재설치하거나 수정이 필요할 때는 반드시 각 어플리케이션의 Finalizer를 먼저 제거하거나 Non-Cascade 전략을 세우자

> Finalizer란? k8s 리소스가가 삭제되기 전에 특정 작업을 수행하도록 보장하는 메커니즘이다.

### 사례 2. 'ingress-system' 네임스페이스 삭제

- **상황:** `istio-system` 네임스페이스를 삭제하기위해 명령어를 실행
- **원인:** `istio-system` 대신 `ingress-system` 앱을 삭제한 사례 (이름이 비슷하여 잘못 삭제한 경우)
- **결과:**: Cascade가 기본 값이었기 때문에 **Ingress Controller와 관련 설정이 통째로 삭제**되었으며 모든 외부 트래픽 차단

### 사례 3. App-of-Apps 체인 리액션 (여러 앱을 하나의 부모앱으로 묶어 사용하는 패턴)
 
- **상황:** 부모 앱이 지저분해 보여서 삭제 시도
- **원인 및 결과:** App of Apps 패턴은 부모앱이 자식앱을 관리하므로 여기에 연결된 **자식 앱 20개가 동시에 삭제**되면서 클러스터가 날라감

---

## 운영 시 참고 사항
- **중요 리소스 어노테이션:** 절대 지워지면 안 되는 리소스에는 아래 설정을 추가하여 Argo CD가 멋대로 지우지 못하게 보호하자
> `argocd.argoproj.io/sync-options: Prune=false`

- **삭제 전 확인 절차:** UI에서 `Delete` 버튼을 누를 때 팝업창의 **[ ] Non-cascading** 꼭 확인하자

---

## Cascade vs Non-Cascade: 선택의 기준

| 선택 | 사용하는 상황 | 이유 |
| --- | --- | --- |
| **Cascade** | **평상시 모든 배포 및 삭제.** 기능 개발 후 테스트 환경 정리, 더 이상 쓰지 않는 서비스 제거 등. | Git에서 삭제했으면 서버에서도 깔끔하게 지워져야 비용과 자원이 낭비되지 않음 |
| **Non-Cascade** | **Argo CD 설정 변경/이관.** Argo CD를 재설치하거나, App 설정을 아예 새로 바꿀 때, 혹은 다른 클러스터로 관리를 넘길 때 | 서비스는 계속 돌아가야 하는데, **Argo CD와의 연결고리만 끊고 싶을 때** 사용 |

---

## 이렇게 위험한데 왜 Non-cascade를 쓰지 않을까?

- 만약 안전하다는 이유로 Non-cascade만 사용하면 아래와 같은 문제가 발생한다.
- **리소스 좀비화:** Git에서는 지웠는데 서버에는 Pod가 계속 떠 있게 되고 관리가 되지 않는다.
- **비용 폭탄:** 삭제된 줄 알았던 서비스가 클라우드 자원(LB, PV 등)을 계속 점유하며 비용이 지속적으로 발생한다. (클라우드 일때)
- **동기화 충돌:** 나중에 같은 이름으로 다시 앱을 등록했을 때, 기존에 남아있던 리소스와 충돌이 발생하여 배포가 꼬일 수 있다.

### "안전"하게 관리하는 더 세련된 방법

- 네임스페이스 전체 삭제같은 대형 사고를 막기 위해 고수들은 삭제 옵션을 바꾸기보다 아래 전략을 쓴다.
- **Prune=false 설정:** 특정 리소스(예: DB용 PVC, Namespace)를 삭제 방지지
```yaml
metadata:
  annotations:
    argocd.argoproj.io/sync-options: Prune=false

```
- **권한 분리:** 일반 개발자는 App 삭제 권한을 주지 않고, 오직 Git의 파일 수정 권한만 주자
- **Finalizer 제거:** 정말 긴급하게 Argo CD만 걷어내야 할 때는 앱의 `metadata.finalizers`를 수동으로 제거하여 안전하게 연결을 끊자

### 요약
- **Non-cascade**는 일상적인 도구가 아니라, 평소에는 **Cascade**를 쓰되, 지워지면 안 되는 핵심 리소스스에만 **보호 장치(Prune=false)**를 걸어두는 것이 안전하다.

## 데이터베이스

### 데이터베이스의 큰 그림
- **DBMS (Database Management System)**: 데이터의 저장, 검색, 갱신, 삭제 등을 관리하는 시스템 소프트웨어
- 파일 시스템보다 효율적인 이유
  - 빠른 검색 (인덱스)
  - 동시성 제어 (Lock, MVCC)
  - 무결성 유지 및 장애 복구 기능
- **Transaction**
  - 데이터베이스의 상태를 변화시키는 작업의 단위
  - ACID 원칙:
    - **원자성 (Atomicity)**: 트랜잭션은 모두 수행되거나 전혀 수행되지 않아야 함
    - **일관성 (Consistency)**: 트랜잭션 수행 전후 데이터 무결성 유지
    - **고립성 (Isolation)**: 동시에 실행되는 트랜잭션 간 간섭 방지
    - **지속성 (Durability)**: 트랜잭션 완료 후 결과는 영구 저장됨

---

### RDBMS와 SQL

- **RDBMS (Relational Database Management System)**:
  - 관계형 모델 기반 테이블 구조
  - 각 테이블은 고유 키(PK)와 외래 키(FK) 등으로 관계를 표현
- **SQL (Structured Query Language)**:
  - DDL (CREATE, ALTER 등), DML (SELECT, INSERT 등), DCL (GRANT, REVOKE)
  - 주요 문법:
    - SELECT ... FROM ... WHERE ...
    - JOIN (INNER, OUTER, LEFT, RIGHT)
    - GROUP BY, HAVING, ORDER BY

---

### RDBMS의 기본

- **정규화(Normalization)**:
  - 중복 최소화, 무결성 유지
  - 1NF, 2NF, 3NF 등 단계별 분리
- **인덱스(Index)**:
  - 검색 성능 향상
  - B-Tree 기반 구조가 일반적
- **옵티마이저(Query Optimizer)**:
  - SQL 실행 계획 수립
  - 통계 정보 기반 비용 기반 최적화 수행

---

### **제1정규형 (1NF)**
- **규칙**: 모든 속성은 더 이상 쪼갤 수 없는 원자값(Atomic Value)만 가져야 한다.
- **예시**
  ```
  학생(학번, 이름, 전화번호)
  1001, 홍길동, 010-1111-1111; 010-2222-2222   ← 한 칸에 여러 값
  ```
- **정규화 후**
  ```
  학생(학번, 이름, 전화번호)
  1001, 홍길동, 010-1111-1111
  1001, 홍길동, 010-2222-2222
  ```
### **제2정규형 (2NF)**
- **규칙**: 부분 함수 종속 제거 (복합키 일부에만 종속된 속성 제거)
- **예시**
  ```
  수강(학번, 과목코드, 학생이름)
  ```
  - 기본키 = (학번, 과목코드)
  - `학생이름`은 학번에만 종속 → 부분 종속 발생
- **정규화 후**
  ```
  학생(학번, 이름)
  수강(학번, 과목코드)
  ```

### **제3정규형 (3NF)**
- **규칙**: 이행 함수 종속 제거 (기본키가 아닌 다른 속성에 종속된 속성 제거)
- **예시**
  ```
  학생(학번, 이름, 학과코드, 학과이름)
  ```
  - 기본키 = 학번
  - `학과이름`은 학번이 아니라 `학과코드`에 종속 → 이행 종속
- **정규화 후**
  ```
  학생(학번, 이름, 학과코드)
  학과(학과코드, 학과이름)
  ```
### **BCNF (Boyce-Codd Normal Form)**
- **규칙**: 모든 결정자(Determinant)는 반드시 슈퍼키여야 함
- **예시**
  ```
  강의(교수, 과목, 강의실)
  ```
  - 규칙: 교수 → 과목, 과목 → 강의실
  - 후보키: (교수, 과목), (과목, 강의실)
  - 문제: `과목`이 `강의실`을 결정하지만, `과목`은 슈퍼키가 아님 → 3NF는 만족하지만 BCNF는 위반
- **정규화 후**
  ```
  교수과목(교수, 과목)
  과목강의실(과목, 강의실)
  ```

#### 요약
- **1NF**: 원자값만 허용
- **2NF**: 복합키 일부에만 종속된 속성 제거
- **3NF**: 기본키 아닌 속성 간 종속 제거
- **BCNF**: 모든 결정자가 슈퍼키여야 함
---

### NoSQL

- **NoSQL**:
  - Not Only SQL: 비정형 또는 반정형 데이터에 적합
  - 수평 확장성(Horizontal Scalability)에 강점
  - 스키마 유연성, 고가용성

#### 주요 유형 및 특징

- **Key-Value Store**:
  - 예: Redis, Riak
  - 빠른 읽기/쓰기 성능, 단순 구조
- **Document Store**:
  - 예: MongoDB, CouchDB
  - JSON, BSON 형식으로 저장, 유연한 구조
- **Column Store**:
  - 예: Cassandra, HBase
  - 대용량 분석용에 적합
- **Graph DB**:
  - 예: Neo4j
  - 노드-엣지 구조, 관계 탐색에 최적

#### 대표 NoSQL

- **MongoDB**:
  - 도큐먼트 기반, BSON 포맷
  - 복잡한 쿼리와 인덱스 지원
- **Redis**:
  - 인메모리 키-값 저장소
  - TTL, pub/sub, 캐시, 세션 저장 등에 활용
---

## 샤딩이란

**정의**  
하나의 거대한 데이터베이스를 여러 개의 작은 데이터베이스(샤드)로 나눠 저장하고, 각각을 독립적으로 운영하는 수평 확장 기법  

**이유**  
MySQL 같은 단일 인스턴스는 저장 용량, QPS(초당 요청 수), 디스크 IO, 백업/복구 시간에 한계가 있음  
데이터를 나누면 서버 여러 대가 나눠 처리하므로 한 서버에 몰리는 부하를 줄일 수 있음  

---

### 1. 범위 샤딩 (Range Sharding)
- **개념**: 특정 컬럼 값의 범위로 샤드를 나눔  
- **예시**: user_id 1~1M → shard1, 1M+1~2M → shard2  
- **특징**: 특정 구간에 데이터가 몰릴 수 있어 “핫샤드” 위험이 있음  

### 2. 해시 샤딩 (Hash Sharding)
- **개념**: 샤딩 키에 해시 함수를 적용해 샤드 번호를 계산  
- **예시**: user_id % 8 → shard 번호  
- **특징**: 데이터가 비교적 균등하게 분산됨  
  다만 리샤딩(샤드 수 변경) 시 재배치 부담이 큼  

### 3. 디렉토리/룩업 샤딩 (Directory / Lookup Sharding)
- **개념**: 별도 매핑 테이블(샤드 맵)이나 메타데이터 서비스에서 “키 → 샤드” 매핑을 관리  
- **예시**: customer_id=12345 → shard7이 매핑 테이블에 저장됨  
- **특징**: 유연하게 재배치 가능  
  대신 매핑 저장소를 따로 운영해야 하고 조회 오버헤드가 있음  


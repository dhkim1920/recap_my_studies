## Airflow on Kubernetes 운영 방식 비교

### 1. Celery Executor on K8s (일반적인 방식)

K8s 환경 위에 고정된 수의 Worker Pod를 띄워두고 Celery Queue를 통해 작업을 처리하는 방식

**장점**

- **낮은 지연 시간(Low Latency):** Worker가 이미 실행 중이므로 Task가 할당되자마자 즉시 실행
- **성능 예측 가능:** 고정된 리소스 내에서 작업이 수행되므로 전체 시스템 부하를 예측 가능
- **관리가 익숙함:** 기존 Celery 방식의 운영 노하우를 그대로 K8s 환경에 적용 가능

**단점**

- **리소스 낭비:** 실행할 Task가 없어도 Worker Pod가 상시 대기해야 하므로 비용이 계속 발생
- **환경 격리 부족:** 하나의 Worker Pod 내에서 여러 Task가 실행될 경우, 특정 Task가 메모리를 과다 점유하면 다른 Task에 영향을 줄 수 있다.
- **확장의 한계:** 동적으로 Worker 수를 조절하려면 별도의 Autoscaler(KEDA 등) 설정이 필요

---

### 2. Kubernetes Executor (K8s 네이티브 방식)

Task 하나당 Pod 하나를 매번 새로 생성하여 실행하는 방식

**장점**

- **최고의 비용 효율성:** 작업이 있을 때만 Pod를 띄우고 끝나면 바로 삭제하므로 리소스 낭비가 거의 없음 (Scale-to-Zero).
- **완벽한 격리:** 각 Task가 독립된 Pod에서 실행되므로 상호 간섭이 전혀 없으며, 개별 Task마다 필요한 CPU/메모리를 다르게 설정 가능
- **환경 유연성:** Task마다 서로 다른 컨테이너 이미지를 사용할 수 있어 라이브러리 충돌 문제에서 자유로움

**단점**

- **오버헤드 및 지연 시간:** Task를 실행할 때마다 Pod를 생성하고 컨테이너 이미지를 불러오는(Pull) 시간이 추가로 소요
- **K8s API 서버 부하:** Task가 매우 많고 실행 주기가 짧을 경우, 빈번한 Pod 생성/삭제 요청으로 인해 Kubernetes API 서버에 부하를 줄 수 있다.
- **설정 복잡도:** Task별로 `executor_config`를 세세하게 관리해야 할 경우 코드가 복잡해질 수 있음음

---

### 3. 비교 요약

| 항목 | Celery on K8s | Kubernetes Executor |
| --- | --- | --- |
| **Worker 관리** | 상시 가동 (Static/Auto-scaling) | 동적 생성 (On-demand) |
| **실행 속도** | 빠름 (즉시 실행) | 보통 (Pod 생성 시간 필요) |
| **리소스 효율** | 낮음 (유휴 리소스 발생 가능) | **높음 (사용한 만큼만 점유)** |
| **격리 수준** | 낮음 (Worker 공유) | **높음 (Pod 단위 독립)** |
| **추천 상황** | 작업량이 일정하고 빠른 실행이 중요한 경우 | 작업량 변화가 크고 개별 작업 환경이 복잡한 경우 |
